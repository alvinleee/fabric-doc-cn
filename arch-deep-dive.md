# 架构解读
Hyperledger Fabric架构提供以下优点：

* 链码信任的灵活性。该架构将链码(区块链应用)的信任假设与排序节点的信任假设相分离。换句话说，排序服务可以由一组节点(排序节点)提供，并且容许他们中的一些节点出现故障或不正当行为，并且背书节点对于每个链码来说可能都是不同的。
* 可扩展性。 由于负责特定链码的背书节点与排序节点正交，所以当前系统与这些功能由相同节点完成相比较具有更好的性能。 特别地，当不同的链码指定不相交的背书节点时，这种结果引入了背书节点之间链码的相互分隔，并允许并行的执行链码(背书)。 此外，从排序服务的关键路径中删除可能消耗高昂成本的链码执行。
* 保密性。 该架构便于部署在更新其交易时对内容和状态有保密性需求的链码。
* 共识模块化。 该架构是模块化的，并且允许可插拔共识的实现(即，排序服务)。

### 第一部分：与*Hyperledger Fabric v1*相关的元素架构
1. 系统架构
2. 交易背书的基本工作流程
3. 背书策略

### 第二部分：Post-v1 elements of the architecture
4. 账本检查点(修剪)

##  1. 系统架构
区块链是由许多节点组成的分布式系统，它们彼此通信。 区块链运行称为链码的程序，保存状态和账本数据，并执行交易。 链码是中间元素，因为事务是在链码上调用的操作。 交易必须“被认可”，只有被背书的交易才能被提交并对状态产生影响。 存在用于管理功能和参数的一个或多个特殊链码，统称为系统链码。

### 1.1 事务
事务分为两种类型

* 部署事务会创建新的链码并以它为参数执行程序。 当部署事务成功执行时，链码已被安装在区块链上。
* 调用事务在先前部署的链码的上下文中执行操作。 调用事务指的是一段链码及其提供的一个功能。 当成功时，链码执行指定的功能 - 这可能涉及修改相应的状态，并返回一个输出。
如后所述，部署事务是调用事务的一种特殊情况，部署事务创建新的链码相当于在一个系统链码上执行一次调用事务。
> 备注：本文档假设事务是指创建新的链码，或者调用一个*已经部署的链码提供的操作。 本文档还没有描述：a)查询(只读)事务的优化(包含在v1中)，b)支持跨链码的事务(post-v1功能)。

## 1.2 区块链数据结构
### 1.2.1 状态
区块链(或简单的状态)的最新状态被建模为版本化键/值存储(KVS)，其中键是名称，值是任意的blob。 这些条目由运行在区块链上的链码(应用程序)通过put和get的KVS操作来进行操作。 状态被永久存储，并且状态的更新会被记录。 注意，版本化的KVS被采用为状态模型，可以使用实际的KVS来实现，也可以使用RDBMS或任何其他解决方案来实现。
更正式地，状态s被建模为映射K- >(V X N)的元素 ，其中：
* K是一组键。
* V是一组值。
* N是版本号的无限有序集合。 注入函数next：N - > N，取N中的一个元素并返回下一个版本号。

V和N都包含一个特殊元素\bot，这在N是最低元素的情况下。 最初所有的键映射到(\bot，\bot)。 对于s(k)=(v，ver)，我们用s(k).value表示v，由s(k).version表示ver。

KVS操作的建模如下:
* put(k,v), 对于K中的k，V中的v，获取区块链状态s，并将其改变为s'，使得 s'(k)=(v,next(s(k).version)),对于所有的k'!=k， s'(k') = s(k')。
> put这一段看不懂，哪位大神给解释一下。

* get(k), 返回s(k)。

状态由对等节点维护，但不由排序节点和客户端维护。

状态分隔。 KVS中的key可以从其名称中识别其属于特定的链码，因此只有特定链码的事务可以修改属于该链码的key。 原则上，任何链码都可以读取属于其它链码的key。 跨链码交易支持修改属于两个或更多链码的状态是post-v1的一个功能。

### 1.2.2 账本
帐本提供了在系统运行期间发生的所有成功的状态变化(我们指的是有效的交易)和不成功的改变状态的尝试(我们指的是无效的交易)的可验证的历史记录。

帐本由排序服务构建(见第1.3.3节)，作为(有效或无效)交易所属区块的完全有序的哈希链。 哈希链将账本中所有的区块进行排序，每个区块包含一个由完全排序过的交易组成的数组。 这就对所有交易都进行了排序。

账本被保留在所有对等节点中，并且可选地,在排序节点上保存账本的一个子集。 在排序节点的上下文中，我们将帐本称为*OrdererLedger*，而在对等节点的上下文中，我们将帐本称为*PeerLedger*。 *PeerLedger*与*OrdererLedger*不同之处在于，对等节点本地保留了一个用来从无效的交易中分离有效交易的位掩码(有关详细信息，请参见第XX部分)。

如第XX部分(post-v1功能)中所述, 对等节点可以修剪*PeerLedger*。排序节点维护*OrdererLedger*是为了*PeerLedger*的容错性和可用性，并且假若排序服务的属性(见第1.3.3节)被维护时, 排序节点可以随时修改*OrdererLedger*。

账本允许对等体回放所有交易的历史记录并重建状态。 因此，第1.2.1节所述的状态是一个可选的数据结构。

## 1.3 节点
节点是区块链的通信实体。 从不同类型的多个节点可以在同一物理服务器上运行的意义上说，“节点”只是一个逻辑功能。 重要的是如何将节点分组在“信任域”中并与控制它们的逻辑实体相关联。

节点有三种类型:
1. 客户节点或提交客户节点：客户接待向背书节点提交实际的交易调用，并将交易建议广播发送到排序节点。
2. 对等节点：提交交易并维护状态和账本副本(请参见Sec，1.2)的节点。 此外，对等节点可以担任专门的背书节点。
3. 排序服务节点或者排序节点:运行实现传递保证的通信服务的节点，例如原子或总订单广播。

接下来将详细地解释各个节点的类型。

### 1.3.1 客户端
客户端代表是最终用户利益的实体。为了跟区块链通信，它必须连接到一个对等节点。客户端可以连接到它选择的任意对等节点。客户端创建并从而调用事务。

客户端于对等节点和排序节点进行通信的细节将在第二节中阐述。

### 1.3.2 对等节点
对等节点以区块的形式从排序服务接收排序状态更新并维护状态数据库和账本。

对等节点可以另外担任背书节点的角色。 背书节点的特殊功能发生在特定的链码，并且在交易提交之前为交易背书。 每个链码都可以指定一个涉及一组背书节点的背书策略。 如第2节和第3节所述，该策略为一个有效的交易背书(通常是一组背书节点的签名)定义了必要和充分的条件。在部署安装新链码的交易的特殊情况下，(部署的)背书策略会被指定为系统链码的背书策略。

### 1.3.3 排序服务节点
所有的排序节点形成排序服务，即，提供传输保证的通信架构。排序服务可以以不同的方式实现：从集中式服务(例如，在开发和测试中使用)到针对不同网络和节点故障模型的分布式协议。

排序服务为客户端和对等节点提供共享的通信通道，为包含交易的消息提供广播服务。客户端连接到通道，并可以在通道上广播消息，然后发送给所有对等节点。通道支持所有消息的原子传递，即具有*total-order*传送和(具体实现)可靠性的消息通信。换句话说，通道向所有连接的对等节点发送相同的消息，并以相同的逻辑顺序将它们发送给所有的对等节点。这种原子通信保证也被称为*total-order*广播，原子广播或在分布式系统的环境中被称为共识。所传送的消息是包含在区块链状态中的候选交易。

**分区(排序服务中的通道)。** 排序服务可以支持与发布/订阅(pub / sub)消息系统的主题相似的多通道功能。客户端可以连接到给定的通道，并可以收发消息。通道可以被认为是分区 - 连接到一个通道的客户端不知道其它通道的存在，但是客户端可以连接到多个通道。即使*Hyperledger Fabric*中包含的一些排序服务实现了支持多通道，为了描述简单，在本文档的其余部分中，我们假设排序服务由单个渠道/主题组成。

**排序服务 API** 对等节点通过排序服务提供的接口连接到排序服务提供的通道。排序服务API由两个基本操作(通常是异步事件)组成:

**TODO** 在客户端/对等节点指定的序列号下添加API的一部分可以获取特定的区块。

* broadcast(blob)：为了在通道中传播，一个客户端可以调用这个操作广播一个任意信息blob。当向一个服务发送请求时，在BFT的环境中这个被称为调用(blob)。

* deliver(seqno, prevhash, blob)：排序服务在对等节点上调用这个操作来传递包含特定的非负整数序列号(*seqno*)和最新传递的*blob*的哈希值(*prevhash*)的消息*blob*。换句话说，它是来自排序服务的输出事件。deliver()在订阅-发布系统中被称为notify()或者在BFT系统中被称为commit()。

**账本和区块格式** 帐本(参见第1.2.2节)包含排序服务输出的所有数据。简而言之，它是一系列*deliver(seqno, prevhash, blob)*事件，它们根据*prevhash*的计算形成的一个哈希链。

大多数情况下，出于效率的原因，订单服务不会输出单个交易(blob)，而是对*blob*进行分组打包并作为为单个*deliver*事件中区块输出。在这种情况下，排序服务必须强制传输每个区块内的*blob*的确定性排序。通过排序服务实现可以动态地选择区块中*blob*的数量。

在下文中，为了便于介绍，我们定义了排序服务属性(本小节的其余部分)，并解释了假设每个deliver 事件有一个blob情况下的交易背书的工作流程(第2节) 。假设一个区块的一个*deliver*事件与区块内每个blob单独的*deliver*事件的一个序列号相对应，根据前面介绍的区块内*blob*的确定性排序, 这些容易地扩展到区块。

**排序服务属性**

排序服务(或原子广播通道)的保证规定广播消息会发生什么以及传递的消息之间存在什么关系。 这些保证如

1. **安全(一致性保证):** 只要对等节点连接到通道足够长的时间(它们可以断开或崩溃，但将重新启动和重新连接)，他们将看到相同的一系列传输 *(seqno, prevhash, blob)* 的消息。 这意味着输出(*deliver()*事件)在所有对等节点上以相同的顺序发生，输出是按照序列号排序的并且对于相同序列号的输出携带着相同的内容(*blob* 和 *prevhash*)。请注意，这只是一个逻辑顺序，并且一个对等节点上的一个*deliver(seqno, prevhash, blob)*并不需要和另一个对等节点上输出相同消息的*deliver(seqno, prevhash, blob)*之间有任何的实时关系。换句话说，给定一个特定的*seqno*，没有两个正确的对等节点会输出不同的*prevhash*或*blob*值。此外，除非一些客户端(对等节点)实际上调用了广播功能(blob),并且每个被广播的*blob*只会被发送一次，否则不传递任何值(*blob*)。

此外，*deliver()*事件包含先前的*deliver()*事件*(prevhash)*中的数据的加密哈希值。 当排序服务实现原子广播保证时，*prevhash*是序列号为*seqno-1*的*deliver()*事件的参数的加密哈希值。 这将建立一个跨*deliver()*事件的哈希链，用于帮助验证排序服务输出的完整性，稍后将在第4节和第5节中讨论。 在第一个*deliver()*事件的特殊情况下，*prevhash*具有默认值。

2. **活力(交付保证)：** 排序服务的活力保证由一个排序服务的实现指定。 确切的保证可能取决于网络和节点故障模型。

原则上，如果提交的客户端没有出现故障，则排序服务应保证连接到排序服务的每个正确的对等节点最终都会传输每个被提交的交易。

总而言之，排序服务要确保一下属性：

* 一致性。对于正确对等节点上的任意两个拥有相同*seqno*的事件*deliver(seqno, prevhash0, blob0)* 和 *deliver(seqno, prevhash1, blob1)* ，则*prevhash0==prevhash1*并且*blob0==blob1*;
* 哈希链完整性。对于正确对等节点上的任意两个事件*deliver(seqno-1, prevhash0, blob0)* 和 *deliver(seqno, prevhash, blob)*, *prevhash = HASH(seqno-1||prevhash0||blob0)*;
* 不可跳过。如果排序服务在正确的对等节点*p*输出*deliver(seqno，prevhash，blob)*，如果*seqno> 0*，那么*p*肯定已经传送了一个事件*deliver(seqno-1，prevhash0，blob0)*。
* 不能创作。 在一个正确的对等节点上的任何事件*deliver(seqno，prevhash，blob)*必须在一些(可能是不同的)对等节点的广播(*blob*)事件之前;
* 不能重复(可选，但可取)。 对于任意两个事件*broadcast(blob)*和*broadcast(blob')*,当两个事件*deliver(seqno0，prevhash0，blob)*和*deliver(seqno1，prevhash1，blob')*发生在正确的对等节点并且*blob == blob'*时，则*seqno0 = = seqno1*并且*prevhash0 == prevhash1*
* 活跃度。 如果正确的客户端调用事件broadcast(blob)，则每个正确的对等节点“最终”发出一个事件deliver(*，*，blob)，其中*表示任意值。

## 2. 交易背书的基本工作流
接下来我们概述一个交易的高级请求流程。
> 请注意，以下协议并不认为所有交易都是确定性的，即允许非确定性交易。

### 2.1 客户端创建一个交易并发送到选定的背书节点
为了调用一个交易，客户端会向所选择的一组背书节点发送一个*PROPOSE*消息(可能不是同时 - 见2.1.2和2.3节)。 客户端可以通过对等节点得到特定*chaincodeID*的一组背书节点，而后者又通过背书策略可以知道一组背书节点(见第3节)。 例如，交易可以发送给一个特定*chaincodeID*的所有背书节点。 也就是说，一些背书节点可能离线，其他背书节点可能会拒绝并选择不为交易背书。 提交客户端尝试通过可用的背书节点来满足策略表达式。

接下来，我们首先详细说明*PROROSE*消息格式，然后讨论提交客户端和背书节点之间可能的交互模式。

#### 2.1.1 *PROPOSE* 消息格式
一个*PROPOSE*消息的格式为<*PROPOSE,tx,[anchor]*>, *tx*是必选参数，*anchor*是可选参数，接下来将详细解释这两个参数:

* *tx*=<*clientID,chaincodeID,txPayload,timestamp,clientSig*>

   * *clientID*是提交客户端的ID。
   * *chaincodeID*是交易所涉及链码的ID。
   * *txPayload*是包含提交的交易本身的有效载荷。
   * *timestamp*时间戳。由客户端维护的单调递增(对于每个新交易)整数。
   * *clientSig* *tx*中其它领域的客户端的签名。

   调用事务和部署事务之间的*txPayload*细节会有所不同(即调用事务涉及特定于部署的系统链码)。

   对于调用事务， *txPayload*将由两个字段组成：
   * *txPayload* = <*operation, metadata*>

        * *operation* 表示链码操作(函数)和参数。
        * *metadata* 表示与调用相关的属性。

    对于部署事务，*txPayload*将由两个字段组成：

    * *txPayload* = <*source, metadata, policies*>

        * *source* 表示链码的源码。
        * *metadata* 表示与链码和应用相关的属性。
        * *policies* 包含与所有对等节点可以访问的链码相关的策略，比如背书策略。需要注意的是，部署*deploy*事务中的*txPayload*不支持背书策略，但是部署*deploy*事务中的*txPayload*包含背书策略ID和它的参数。

* *anchor* 包含读取版本依赖关系，或者更具体地说，键和版本组成的键值对(即，锚是KxN的子集)，其将*PROPOSE*请求绑定或“锚定”到*KVS*中的指定*key*的版本(参见第1.2节)。 如果客户端指定了锚参数，则背书节点只能在读取其本地KVS匹配所有节点把tx的加密哈希值用作唯一的事务标识符tid(即，tid = HASH(tx))。

客户端将tid存储在内存中，并等待来自背书节点的响应。锚中的相应键的版本号后，才会为交易背书(有关详细信息，请参阅第2.2节)。

###2.1.2 消息模式
客户端决定与背书节点的互动顺序。 例如，客户端通常将<*PROPOSE，tx*>(即，没有锚参数)发送到单个背书节点，然后背书节点将产生版本相关性(锚点)，客户端稍后可以将锚点作为其*PROPOSE*消息的参数发送给其他背书节点。 另一个例子，客户端可以直接将<*PROPOSE，tx*>(无锚点)发送给其所选的所有背书节点。 不同的通信方式是可能的，客户可以自由决定这些(另见第2.3节)。

## 2.2 背书节点模拟交易并产生一个背书签名
在接收到来自客户端的<*PROPOSE，tx，[anchor]*>消息时，背书节点*epID*首先验证客户端的签名 *clientSig*，然后模拟执行交易。 如果客户端指定了锚点，则只有当背书节点读取本地*KVS*中的相应*key*的版本号(如下所定义的读取集合)与锚点指定的版本号相匹配时，背书节点才会模拟执行交易。

模拟交易包括通过调用交易相关的链码(*chaincodeID*)和背书节点本地保存的状态数据库的副本，来暂时执行交易(*txPayload*)。

作为执行的结果，背书节点计算读取版本依赖性(readset)和状态更新(writeset)，在DB语言也被称为MVCC + postimage信息。

回想一下，状态由键/值(k / v)组成。 所有k / v条目都进行版本控制，也就是说，每个条目都包含有序的版本信息，这个版本信息在每次更新存储在键下面的值时会增加。 解释交易的对等节点会记录被链码访问过的所有k / v对，无论是用于读取或写入，但是对等节点不会更新其状态。 进一步来说：

* 在背书节点执行交易之前给定一个状态s，对于由交易读取的每个键 k，将(k，s(k).version)键值对，添加到读集。
* 另外，对于被交易修改的每个键 k的新值 v'，(k，v')被添加到写集。 或者，v'可以是新值到先前值(s(k).value)的增量。

如果客户端在PROPOSE消息中指定了锚点，则客户端指定的锚点必须等于在模拟交易时由背书节点产生的读集。

然后，对等节点将内部交易提案(也可能是tx)转发到其(对等节点)逻辑中为交易背书的部分(称为背书逻辑)。 默认情况下，对等节点的背书逻辑接受交易提案，并简单地签署交易提案。 然而，背书逻辑可以解释任意的功能，例如与具有交易提案和tx作为输入的遗留系统交互以达成是否为交易背书的决定。

如果背书逻辑决定为交易背书，则会向提交客户端(tx.clientID)发送<TRANSACTION-ENDORSED，tid，tran-proposal，epSig>消息，其中：

* *tran-proposal：=(epID，tid，chaincodeID，txContentBlob，readset，writeset)*， 其中txContentBlob是链码/事务特定的信息。 意图是将txContentBlob用作tx的一些表示(例如，txContentBlob = tx.txPayload)。

* epSig是交易提案中背书节点的签名。

否则，如果背书逻辑拒绝为交易背书，则背书节点向提交客户端发送消息(TRANSACTION-INVALID，tid，REJECTED)。

请注意，在此步骤中，背书节点不会更改其状态，在背书节点下通过模拟交易生成的更新不会影响状态！

### 2.3 提交客户端收集交易的背书签名，并通过排序服务进行广播
提交客户端等待，直到它收到(TRANSACTION-ENDORSED，tid，*，*)语句中的“足够”消息和签名，以得出交易提案被认可。 如2.1.2节所述，这可能涉及到与一个或多个背书节点的反复交互。

“足够”的确切数量取决于链码背书策略(另见第3节)。 如果背书策略得到满足，交易就已获得批准; 注意此时它还没有被提交。从确立交易被认可的背书节点收集被签名过的TRANSACTION-ENDORSED消息被称为一次背书。

如果提交客户端没有收集到一个交易提案的背书，则会放弃此交易，并提供稍后重试的选项。

对于有效背书的交易，我们现在开始使用排序服务。 提交客户端使用broadcast(blob)调用排序服务，其中blob =背书。 如果客户端没有直接调用排序服务的能力，它可以通过其选择的某个对等节点代理其广播。 这样的对等节点必须被客户信任，不能从背书中删除任何消息，否则交易可能被视为无效。 请注意，然而，代理对等节点可能无法制造有效的背书。

### 2.4 排序服务发送交易给对等节点
当一个事件deliver(seqno，prevhash，blob)发生，并且当序列号低于seqno时一个对等节点会对更新blob的所有状态，对等节点执行以下操作：
* 它根据其引用的链码(blob.tran-proposal.chaincodeID)的背书策略来检查blob.endorsement是否有效。
* 在典型的情况下，它也会同时验证依赖关系(blob.endorsement.tran-proposal.readset)是否被违反。 在更复杂的使用案例中，交易提案中的背书可能不同，在这种情况下，背书策略(第3节)规定了状态如何演变。

为了更新状态可以选择一致性属性或“隔离保证”来以不同的方式实现依赖关系的验证。 串行化是默认的隔离保证，除非链码的背书策略略指定了不同的方式。 串行化可以通过要求读集中的每个键相关联的版本都等于该状态下的键的版本，并拒绝不满足此要求的交易来提供。

* 如果所有这些检查通过，交易被视为有效或可提交。 在这种情况下，对等体在PeerLedger的位掩码中将事务标记为1，将blob.endorsement.tran-proposal.writeset应用于区块链状态(如果交易提案相同，否则背书策略逻辑定义了获取Blob的函数 。背书)。
* 如果blob.endorsement的背书策略验证失败，则该交易无效，并且对等节点会在PeerLedger的位掩码中将该交易标记为0。 要注意，无效的交易不会改变状态。

请注意，这足以使所有(正确的)对等节点在处理具有给定序列号的deliver事件(块)之后具有相同的状态。 也就是说，通过排序服务的保证，所有正确的对等节点将接收到相同顺序的deliver(seqno，prevhash，blob)事件。 由于对背书策略的评估和对读集中的版本依赖性的评估是确定性的，所以无论一个blob中包含的事务是否有效，正确的对等节点也将得出相同的结论。 因此，所有对等节点提交并采用相同的交易序列，并以相同的方式更新其状态。

![image](http://hyperledger-fabric.readthedocs.io/en/latest/_images/flow-4.png)

图1.一个可能的交易流程(普通案例路径)。

## 3. 背书策略

### 3.1 背书策略规范
背书策略是对一个交易进行背书的条件。 区块链对等节点具有一组预先指定的背书策略，这些策略由安装特定链码时的部署事务引用。 背书策略可以参数化，这些参数可以由部署事务指定。

为了保证区块链和安全属性，一套背书策略应该是一套具有有限功能的，并能够确保有限的执行时间(终止)，确定性，性能和安全性保证的成熟策略。

在有限政策评估时间(终止)，确定性，绩效和安全保障方面，动态添加背书策略(例如通过在链码部署时间部署事务)非常敏感。 因此，不允许动态添加背书政策，但将来可以支持。

### 3.2 对背书策略的交易评估
只有当交易根据背书策略被认可时，交易才被宣告为有效。 链码的调用事务首先必须获得满足链码背书策略的背书，否则将不会被提交。 这是通过提交客户端和背书节点之间的交互进行的，如第2节所述。

正式的背书政策是背书的一个谓词，并且潜在的进一步的状态评估为TRUE或FALSE。 对于部署事务，根据系统范围的策略(例如，从系统链码)获得认可。

背书策略谓词是指某些变量。 潜在的可能是指
1. 与链码相关的密钥或身份(在链码的元数据中找到)，例如一组背书节点;
2. 链码的更多元数据；
3. endorsement 和 endorsement.tran-proposal的元素
4. 并且可能更多。

上面的列表是通过增加表现形式和复杂性来排序的，也就是说，支持只涉及节点的密钥和身份的策略将比较简单。

对背书策略谓词的评估必须是确定性的。 每个对等节点应当在本地评估背书，以便对等节点不需要与其他节点进行交互，但所有正确的对等节点都以相同的方式评估背书策略。

### 3.3 背书策略示例
背书策略包含逻辑表达式，并且计算结果为*TRUE*或者*FALSE*。

通常，条件是在事务调用上使用由链码上的背书节点出具的数字签名。

假设链码指定了背书节点集 *E = {Alice, Bob, Charlie, Dave, Eve, Frank, George}*。一些背书策略的示例如下所示：
* 来自*E*中所有成员对同一个交易提案的签名是一个有效签名。

* 来自*E*中任意单个成员的签名是一个有效签名。

* 对相同交易提案的有效签名必须来自满足条件*(Alice OR Bob) AND (any two of: Charlie, Dave, Eve, Frank, George)* 的背书节点。

* 对同一交易提案来说，7个背书节点中任意5个对其签名就是有效签名。(通常来说，对于具有*n > 3f* 个背书节点的链码，有效的签名是指*n*个背书节点中有超过 *2f+1* 个背书节点或者在任意背书组中超过 *(n+f)/2* 个背书节点为其背书。

* 假设每个背书节点有一个“股份”或“权重”的参数，如 *{Alice = 49，Bob = 15，Charlie = 15，Dave = 10，Eve = 7，Frank = 3，George = 1}* 总股本为100：该策略要求一个拥有多数股权的集合(即，一个总股份必须超过50的组)的有效签名，例如与*Alice*和除了*George*之外的任何人{Alice，X}，或除了爱丽丝之外的所有人 *{everyone together except Alice}*。 等等。

* 前面示例条件中的股份分配可以是静态的(固定在链码的元数据中)或动态的(例如，取决于链码的状态，并且在执行期间被修改)。

* *(Alice OR Bob)* 对*tran-proposal1*的有效签名以及来自 *(any two of: Charlie, Dave, Eve, Frank, George)* 中的任何两个的有效签名)，其中 *tran-proposal1* 和*tran-proposal2* 仅在其背书节点和状态更新方面有所不同。

如何使用策略取决于应用程序, 解决方案所需的弹性是针对背书节点的失败或不当行为以及各种其他属性。

## 4 (POST-V1)。 账本验证和对等节点账本的检查点(修剪)
### 4.1 验证账本 *(VLedger)*

为了保持账本的抽象概念，只包含有效和已提交的交易(例如在比特币中的实现)，除了状态和账本之外，对等节点可以维护验证账本(*VLedger*)。 这是通过过滤掉无效事务从账本派生的哈希链。

*VLedger* 区块的构造(这里称为 *vBlock* )如下所示。 由于 *peerledger* 中的区块可能包含无效的交易(即具有无效的背书或无效的版本依赖的交易)，所以在从一个区块的交易添加到 *vBlock* 之前，这些交易会被对等节点过滤掉。 每个对等节点本身来执行此操作(例如，通过使用与  *PeerLedger* 相关联的位掩码)。 *vBlock* 被定义为没有包含已被过滤掉的无效交易的区块。 这样的vBlock的大小在本质上是动态的，也可能是空的。 vBlock构造的图示如下图所示。

![image](http://hyperledger-fabric.readthedocs.io/en/latest/_images/blocks-3.png)

图2: 从账本(*PeerLedger*)中形成验证账本区块(*vBlock*)的示意图

每个对等节点通过哈希链将 *vBlock* 相互链到一起。更确切的说： 验证账本的每个区块包括：
* 前一个 *vBlock* 的哈希值。
* *vBlock* 的序列号。
* 自从上一个 *vBlock* 被计算出来以来，由对等节点提交的所有有效交易的一个有序列表。(即，相应区块中所有有效交易的列表)
* 派生出当前 *vBlock* 的相应区块(在 *PeerLedger* 中)的哈希值。

所有这些信息被对等节点索引和哈希，从而产生验证帐本中的vBlock的哈希值。

### 4.2 *PeerLedger* 检查点
账本含有无效的交易，但是不一定会永久记录。 然而，对等节点不能简单地丢弃 *PeerLedger* 区块，从而在建立对应的 *vBlock* 时修剪 *PeerLedger* 。 也就是说，在这种情况下，如果新的对等节点加入网络，则其他对等节点不能将丢弃的区块(与 *PeerLedger* 相关)传送到加入的对等节点，也不能使新加入的对等节点信服其 *vBlock* 的有效性。

为了方便的修剪 *PeerLedger* ，本文介绍了一种检查点机制。 这种机制确立了跨对等节点网络的   *vBlock* 的有效性，并允许检查点的 *vBlock* 替换被丢弃的PeerLedger区块。 因为不需要存储无效的交易，这反过来又减少了存储空间。 它还减少了加入网络的新对等节点重建状态的工作量(因为在通过回放 *PeerLedger* 来重建状态的时候，他们不需要确立单个事务的有效性，而是可以简单地回放包含在验证账本中的状态更新)。

#### 4.2.1 检查点协议
检查点由对等节点的每个 *CHK* 区块定期执行，其中 *CHK* 是一个可配置参数。 要初始化一个检查点，对等节点要向其他对等节点发送广播(例如，*gossip* )消息 *<CHECKPOINT，blocknohash，blockno，stateHash，peerSig>* ，其中 *blockno* 是当前区块的序列号，*blocknohash* 是其对应的哈希值，*stateHash* 是在区块blockno的验证之后的最新状态的哈希值 (例如，由 *Merkle* 哈希生成)并且 *peerSig* 是对等节点在 *(CHECKPOINT，blocknohash，blockno，stateHash)* 上的签名，参考验证账本。

对等节点收集 *CHECKPOINT* 消息，直到获得足够的与 *blockno，blocknohash* 和 *stateHash* 相匹配的正确签名消息，以建立有效的检查点(参见第4.2.2节)。

一旦为区块编号 *blockno* 和 *blocknohash* 建立起有效的检查点时，一个对等节点：
* 如果 *blockno > latestValidCheckpoint.blockno* ，则对等节点指定 *latestValidCheckpoint =(blocknohash，blockno)*，
* 将组成有效检查点的各个对等节点签名的集合存储到 *set latestValidCheckpointProof* 中，
* 将 *stateHash* 对应的状态存储到 *latestValidCheckpointedState* 中，
* (可选)将其 *PeerLedger* 修剪到区块序列号 *blockno*(包括)。

#### 4.2.2 有效的检查点
显然，检查点协议提出了以下问题：对等节点何时可以修剪它的“ *PeerLedger* ”？ 多少“ *CHECKPOINT* ”消息是“足够多”？ 这些是由检查点有效性策略定义的，至少有两种可能的方法，也可以组合起来：

* 本地(特定对等节点)检查点有效性策略 *( LCVP )* 。 指定对等节点 *p* 上的一个本地策略，它可以指定对等节点 *p* 所信任的对等节点的集合，并且其 *CHECKPOINT* 消息满足建立有效的检查点。 例如， *Alice* 的 *LCVP* 可能会定义 *Alice* 需要从 *Bob* 或者从 *Charlie* 和 *Dave* 接收 *CHECKPOINT* 消息。

* 全局检查点有效性的政策 *(GCVP)* 。 被指定为全局性的一个检查点有效性策略。 这与本地对等节点策略相似，除了全局的是在系统(区块链)粒度上规定，而不是在对等节点粒度。 例如， *GCVP* 可以指定：

    * 如果一个检查点由11个不同的对等节点确认，那么每个对等节点都可以信任这个检查点。
    * 在相同机器(即信任域)中每个排序节点和一个对等节点搭配使用，并且最多有f个排序节点可能出现(拜占庭式的)错误的特定环境中，如果一个检查点被f + 1个不同的，和排序节点搭配使用的对等节点确认，那么每个对等节点都可以信任该检查点 。